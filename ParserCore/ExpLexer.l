
%{

//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// NOTE: This source file is was generated by cygwin's flex.exe
//   i.e. flex -L -oCmdLexer.cpp CmdLexer.l
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#include "stdafx.h"
#include <io.h>
#include <string>

#include "ExpParser.h"

extern char* m_expression;

// Otherwise the lexer is file-based.
#define YY_ALWAYS_INTERACTIVE 1

// We *must* override the YY_INPUT macro. Otherwise, the lexer
// thinks the input is coming from stdin.
#define YY_INPUT(buf,result,max_size) \
	if ( true ) \
	{ \
		(*buf) = (*m_expression); \
		++m_expression; \
		if ((*buf) == '\0') \
			(*buf) = (char) EOF; \
		result = (((*buf) != EOF) ? 1 : 0); \
	} \
	else \
	{ \
		errno=0; \
		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
		{ \
			if( errno != EINTR) \
			{ \
				YY_FATAL_ERROR( "input in flex scanner failed" ); \
				break; \
			} \
			errno=0; \
			clearerr(yyin); \
		} \
	}

//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

%}

%%

asin		{ return OP_ASIN; }
acos		{ return OP_ACOS; }
atan		{ return OP_ATAN; }
sin			{ return OP_SIN; }
cos			{ return OP_COS; }
tan			{ return OP_TAN; }

rad			{ return OP_RAD; }
deg			{ return OP_DEG; }

[ \t]		;

[\$\#\~\&\|\?\^@;:(){}\[\]=+\-\*/\%]	{ return yytext[0]; }

[0-9]+					{ yylval.token.coeff = atoi(yytext); return NUMBER; }

([0-9]*\.[0-9]+[eE][-+]?[0-9]+)    { yylval.token.coeff = std::stod(yytext); return NUMBER; }
([0-9]+\.[eE][-+]?[0-9]+)          { yylval.token.coeff = std::stod(yytext); return NUMBER; }
([0-9]*\.[0-9]+)                   { yylval.token.coeff = std::stod(yytext); return NUMBER; }
([0-9]+\.)						   { yylval.token.coeff = std::stod(yytext); return NUMBER; }

[a-zA-Z]	{ yylval.token.coeff = 1.0; return VAR; }

%%

// HERE FOR SAFE KEEPING
// \"[^"\n]*["\n]		{ 
//							if ( strlen(yytext) < 3)
//								yylval.m_string = strdup("");
//							else
//							{
//								yytext[ strlen(yytext)-1 ] = 0;
//								yylval.m_string = strdup(yytext+1);
//							}
//							return STRING;
//						}
						
//[a-zA-Z_][a-zA-Z0-9_]*	{ 
//							yylval.m_string = strdup(yytext);
//							return IDENTIFIER;
//						}

//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// According to the Bison documentation, the default implementation
// of yywrap() always returns 1. So, that is what we do too :-)
//
int yywrap()  { return 1; }

//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// NOTE  NOTE  NOTE  NOTE  NOTE  NOTE  NOTE  NOTE  NOTE  NOTE  NOTE  NOTE
//    The following commentary is more appropo for CmdLexer.
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// 2006.11.26 (PE) -- Introduced this only after much pain & suffering.
// It should be called from yyerror() after processing the error.
// Prior to introducing this function (and for not well understood reasons)
// the parser would puke on a subsequent statement.
//
//    eg. Given the command sequence
//        admin:prepare:          (pass)
//        a^ttrib:headset: .....  (fail, intentional typo)
//        admin:commit:           (fail, lexer in bad state?)
//
// So, now we force the damn thing to be in a decent state.
// NOTE: The failure of admin:commit: may be the reason why the undo buffer
// quits working (as reported by Jonathan McRight).
//
void yyForceRestart()  { yyrestart( yyin ); }
