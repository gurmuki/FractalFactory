#ifndef lint
static const char exp_yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93";
#endif

#define EXP_YYBYACC 1
#define EXP_YYMAJOR 1
#define EXP_YYMINOR 9

#define EXP_YYEMPTY        (-1)
#define exp_yyclearin      (exp_yychar = EXP_YYEMPTY)
#define exp_yyerrok        (exp_yyerrflag = 0)
#define EXP_YYRECOVERING() (exp_yyerrflag != 0)

#define EXP_YYPREFIX "exp_yy"

#define EXP_YYPURE 0


/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
/* BEGIN ** my additions ***/
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/
/**/
/* NOTE: This source file is was generated by cygwin's byacc.exe*/
/*   i.e. byacc -d -l -o CmdParser.cpp CmdParser.y*/
/**/
/*=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=*/

#include "stdafx.h"
#include <map>
#include <stack>
#include <math.h>
#include "MathConst.h"
#include "TokenData.h"
#include "PolyMath.h"

/* The lexer (of course).*/
extern int exp_yylex();

/* See also notes at exp_yyForceRestart().*/
extern void exp_yyForceRestart();

/* A forward reference (compiler fodder)*/
int exp_yyparse();

/* m_expression is the text we are parsing.*/
char*	m_expression;
double	m_value;
bool	m_error;

PolyMath poly;

#ifdef EXP_YYSTYPE
#undef  EXP_YYSTYPE_IS_DECLARED
#define EXP_YYSTYPE_IS_DECLARED 1
#endif
#ifndef EXP_YYSTYPE_IS_DECLARED
#define EXP_YYSTYPE_IS_DECLARED 1
#include "TokenData.h"
typedef union
{
	TokenData token;
} EXP_YYSTYPE;
#endif /* !EXP_YYSTYPE_IS_DECLARED */

/* compatibility with bison */
#ifdef EXP_YYPARSE_PARAM
/* compatibility with FreeBSD */
# ifdef EXP_YYPARSE_PARAM_TYPE
#  define EXP_YYPARSE_DECL() exp_yyparse(EXP_YYPARSE_PARAM_TYPE EXP_YYPARSE_PARAM)
# else
#  define EXP_YYPARSE_DECL() exp_yyparse(void *EXP_YYPARSE_PARAM)
# endif
#else
# define EXP_YYPARSE_DECL() exp_yyparse(void)
#endif

/* Parameters sent to lex. */
#ifdef EXP_YYLEX_PARAM
# define EXP_YYLEX_DECL() exp_yylex(void *EXP_YYLEX_PARAM)
# define EXP_YYLEX exp_yylex(EXP_YYLEX_PARAM)
#else
# define EXP_YYLEX_DECL() exp_yylex(void)
# define EXP_YYLEX exp_yylex()
#endif

/* Parameters sent to exp_yyerror. */
#ifndef EXP_YYERROR_DECL
#define EXP_YYERROR_DECL() exp_yyerror(const char *s)
#endif
#ifndef EXP_YYERROR_CALL
#define EXP_YYERROR_CALL(msg) exp_yyerror(msg)
#endif

extern int EXP_YYPARSE_DECL();

#define NUMBER 257
#define VAR 258
#define OP_EQ 259
#define OP_LE 260
#define OP_GE 261
#define OP_LT 262
#define OP_GT 263
#define OP_NE 264
#define OP_AND 265
#define OP_OR 266
#define OP_XOR 267
#define OP_MIN 268
#define OP_MAX 269
#define OP_LSHIFT 270
#define OP_RSHIFT 271
#define OP_SIN 272
#define OP_COS 273
#define OP_TAN 274
#define OP_ASIN 275
#define OP_ACOS 276
#define OP_ATAN 277
#define OP_RAD 278
#define OP_DEG 279
#define UMINUS 280
#define EXP_YYERRCODE 256
static const short exp_yylhs[] = {                           -1,
    0,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,
};
static const short exp_yylen[] = {                            2,
    1,    3,    3,    3,    3,    3,    4,    4,    4,    4,
    4,    4,    4,    4,    3,    2,    1,    1,
};
static const short exp_yydefred[] = {                         0,
   17,   18,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   16,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   15,    0,    0,
    0,    0,    6,   10,   11,   12,    7,    8,    9,   14,
   13,
};
static const short exp_yydgoto[] = {                         13,
   14,
};
static const short exp_yysindex[] = {                       -40,
    0,    0,  -40,  -33,  -19,  -14,  -12,   -7,   -5,    2,
    7,  -40,    0,   25,    0,  -40,  -40,  -40,  -40,  -40,
  -40,  -40,  -40,  -39,  -40,  -40,  -40,  -40,  -40,  -32,
  -25,  -18,  -11,   -4,    3,   11,   18,    0,  -28,  -28,
  -93,  -93,    0,    0,    0,    0,    0,    0,    0,    0,
    0,
};
static const short exp_yyrindex[] = {                         0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   12,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   80,   81,
   51,   73,    0,    0,    0,    0,    0,    0,    0,    0,
    0,
};
static const short exp_yygindex[] = {                         0,
  124,
};
#define EXP_YYTABLESIZE 239
static const short exp_yytable[] = {                         12,
   29,   38,   27,   25,    3,   26,   16,   28,   44,   27,
   25,    1,   26,   27,   28,   45,   27,   25,   28,   26,
   17,   28,   46,   27,   25,   18,   26,   19,   28,   47,
   27,   25,   20,   26,   21,   28,   48,   27,   25,    0,
   26,   22,   28,   49,   27,   25,   23,   26,    0,   28,
    4,   50,   27,   25,   29,   26,    0,   28,   51,   27,
   25,   29,   26,    0,   28,   29,   27,   25,   29,   26,
    0,   28,    5,    0,    0,   29,    0,    0,    0,    2,
    3,    0,   29,    0,    0,    0,    0,    0,    0,   29,
    0,    4,    4,    4,    0,    4,   29,    4,    0,    0,
    0,    0,    0,    0,   29,    0,    0,    0,    0,    0,
    0,   29,    0,    5,    5,    5,    0,    5,   29,    5,
    2,    3,    2,    3,    2,    3,   15,    0,    0,    0,
    0,    0,    0,    0,    0,   24,    0,    0,    0,   30,
   31,   32,   33,   34,   35,   36,   37,    0,   39,   40,
   41,   42,   43,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    1,    2,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    4,    5,    6,    7,    8,    9,   10,   11,
};
static const short exp_yycheck[] = {                         40,
   94,   41,   42,   43,   45,   45,   40,   47,   41,   42,
   43,    0,   45,   42,   47,   41,   42,   43,   47,   45,
   40,   47,   41,   42,   43,   40,   45,   40,   47,   41,
   42,   43,   40,   45,   40,   47,   41,   42,   43,   -1,
   45,   40,   47,   41,   42,   43,   40,   45,   -1,   47,
    0,   41,   42,   43,   94,   45,   -1,   47,   41,   42,
   43,   94,   45,   -1,   47,   94,   42,   43,   94,   45,
   -1,   47,    0,   -1,   -1,   94,   -1,   -1,   -1,    0,
    0,   -1,   94,   -1,   -1,   -1,   -1,   -1,   -1,   94,
   -1,   41,   42,   43,   -1,   45,   94,   47,   -1,   -1,
   -1,   -1,   -1,   -1,   94,   -1,   -1,   -1,   -1,   -1,
   -1,   94,   -1,   41,   42,   43,   -1,   45,   94,   47,
   41,   41,   43,   43,   45,   45,    3,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   12,   -1,   -1,   -1,   16,
   17,   18,   19,   20,   21,   22,   23,   -1,   25,   26,
   27,   28,   29,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  257,  258,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,  272,  273,  274,  275,  276,  277,  278,  279,
};
#define EXP_YYFINAL 13
#ifndef EXP_YYDEBUG
#define EXP_YYDEBUG 0
#endif
#define EXP_YYMAXTOKEN 280
#if EXP_YYDEBUG
static const char *exp_yyname[] = {

"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,"'%'","'&'",0,"'('","')'","'*'","'+'",0,"'-'",0,"'/'",0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"'^'",0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"'|'",0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,"NUMBER","VAR","OP_EQ","OP_LE","OP_GE","OP_LT","OP_GT","OP_NE","OP_AND",
"OP_OR","OP_XOR","OP_MIN","OP_MAX","OP_LSHIFT","OP_RSHIFT","OP_SIN","OP_COS",
"OP_TAN","OP_ASIN","OP_ACOS","OP_ATAN","OP_RAD","OP_DEG","UMINUS",
};
static const char *exp_yyrule[] = {
"$accept : main",
"main : expression",
"expression : expression '+' expression",
"expression : expression '-' expression",
"expression : expression '*' expression",
"expression : expression '/' expression",
"expression : expression '^' expression",
"expression : OP_ASIN '(' expression ')'",
"expression : OP_ACOS '(' expression ')'",
"expression : OP_ATAN '(' expression ')'",
"expression : OP_SIN '(' expression ')'",
"expression : OP_COS '(' expression ')'",
"expression : OP_TAN '(' expression ')'",
"expression : OP_DEG '(' expression ')'",
"expression : OP_RAD '(' expression ')'",
"expression : '(' expression ')'",
"expression : '-' expression",
"expression : NUMBER",
"expression : VAR",

};
#endif

int      exp_yydebug;
int      exp_yynerrs;

int      exp_yyerrflag;
int      exp_yychar;
EXP_YYSTYPE  exp_yyval;
EXP_YYSTYPE  exp_yylval;

/* define the initial stack-sizes */
#ifdef EXP_YYSTACKSIZE
#undef EXP_YYMAXDEPTH
#define EXP_YYMAXDEPTH  EXP_YYSTACKSIZE
#else
#ifdef EXP_YYMAXDEPTH
#define EXP_YYSTACKSIZE EXP_YYMAXDEPTH
#else
#define EXP_YYSTACKSIZE 500
#define EXP_YYMAXDEPTH  500
#endif
#endif

#define EXP_YYINITSTACKSIZE 500

typedef struct {
    unsigned stacksize;
    short    *s_base;
    short    *s_mark;
    short    *s_last;
    EXP_YYSTYPE  *l_base;
    EXP_YYSTYPE  *l_mark;
} EXP_YYSTACKDATA;
/* variables for the parser stack */
static EXP_YYSTACKDATA exp_yystack;

// ============================================================================

extern "C" __declspec(dllexport) int __cdecl ExpParse( const char* expression )
{
	int	status;

	m_value = UNDEFINED;
	m_error = false;

	m_expression = (char*) expression;

	poly.Reset();
	status = exp_yyparse();

	return status;
}

extern __declspec(dllexport) std::string __cdecl ExpParseExpressionGet()
{
	return poly.Expression();
}

extern "C" __declspec(dllexport) int __cdecl ExpParseCountOfTerms()
{
	poly.Reduce();
	return (poly.Terms().size());
}

extern "C" __declspec(dllexport) void __cdecl ExpParseTermsGet(int count, double* coeff, double* expon)
{
	const ExpCoeffs& terms = poly.Terms();
	int limit = terms.size();

	int indx;
	for (indx = 0; indx < count; ++indx)
	{
		coeff[indx] = 0.;
		expon[indx] = 0.;
	}

	indx = 0;
    ExpCoeffs::const_reverse_iterator iter = terms.rbegin();
    while (iter != terms.rend())
	{
		coeff[indx] = iter->second;
		expon[indx] = iter->first;

		++indx;
        ++iter;
	}
}

void exp_yyerror( const char* in_error )
{
	m_error = true;
	exp_yyForceRestart();
}

#if EXP_YYDEBUG
#include <stdio.h>		/* needed for TRACE */
#endif

#include <stdlib.h>	/* needed for malloc, etc */
#include <string.h>	/* needed for memset */

/* allocate initial stack or double stack size, up to EXP_YYMAXDEPTH */
static int exp_yygrowstack(EXP_YYSTACKDATA *data)
{
    int i;
    unsigned newsize;
    short *newss;
    EXP_YYSTYPE *newvs;

    if ((newsize = data->stacksize) == 0)
        newsize = EXP_YYINITSTACKSIZE;
    else if (newsize >= EXP_YYMAXDEPTH)
        return -1;
    else if ((newsize *= 2) > EXP_YYMAXDEPTH)
        newsize = EXP_YYMAXDEPTH;

    i = data->s_mark - data->s_base;
    newss = (short *)realloc(data->s_base, newsize * sizeof(*newss));
    if (newss == 0)
        return -1;

    data->s_base = newss;
    data->s_mark = newss + i;

    newvs = (EXP_YYSTYPE *)realloc(data->l_base, newsize * sizeof(*newvs));
    if (newvs == 0)
        return -1;

    data->l_base = newvs;
    data->l_mark = newvs + i;

    data->stacksize = newsize;
    data->s_last = data->s_base + newsize - 1;
    return 0;
}

#if EXP_YYPURE || defined(EXP_YY_NO_LEAKS)
static void exp_yyfreestack(EXP_YYSTACKDATA *data)
{
    free(data->s_base);
    free(data->l_base);
    memset(data, 0, sizeof(*data));
}
#else
#define exp_yyfreestack(data) /* nothing */
#endif

#define EXP_YYABORT  goto exp_yyabort
#define EXP_YYREJECT goto exp_yyabort
#define EXP_YYACCEPT goto exp_yyaccept
#define EXP_YYERROR  goto exp_yyerrlab

int
EXP_YYPARSE_DECL()
{
    int exp_yym, exp_yyn, exp_yystate;
#if EXP_YYDEBUG
    const char *exp_yys;

    if ((exp_yys = getenv("EXP_YYDEBUG")) != 0)
    {
        exp_yyn = *exp_yys;
        if (exp_yyn >= '0' && exp_yyn <= '9')
            exp_yydebug = exp_yyn - '0';
    }
#endif

    exp_yynerrs = 0;
    exp_yyerrflag = 0;
    exp_yychar = EXP_YYEMPTY;
    exp_yystate = 0;

#if EXP_YYPURE
    memset(&exp_yystack, 0, sizeof(exp_yystack));
#endif

    if (exp_yystack.s_base == NULL && exp_yygrowstack(&exp_yystack)) goto exp_yyoverflow;
    exp_yystack.s_mark = exp_yystack.s_base;
    exp_yystack.l_mark = exp_yystack.l_base;
    exp_yystate = 0;
    *exp_yystack.s_mark = 0;

exp_yyloop:
    if ((exp_yyn = exp_yydefred[exp_yystate]) != 0) goto exp_yyreduce;
    if (exp_yychar < 0)
    {
        if ((exp_yychar = EXP_YYLEX) < 0) exp_yychar = 0;
#if EXP_YYDEBUG
        if (exp_yydebug)
        {
            exp_yys = 0;
            if (exp_yychar <= EXP_YYMAXTOKEN) exp_yys = exp_yyname[exp_yychar];
            if (!exp_yys) exp_yys = "illegal-symbol";
            TRACE("%sdebug: state %d, reading %d (%s)\n",
                    EXP_YYPREFIX, exp_yystate, exp_yychar, exp_yys);
        }
#endif
    }
    if ((exp_yyn = exp_yysindex[exp_yystate]) && (exp_yyn += exp_yychar) >= 0 &&
            exp_yyn <= EXP_YYTABLESIZE && exp_yycheck[exp_yyn] == exp_yychar)
    {
#if EXP_YYDEBUG
        if (exp_yydebug)
            TRACE("%sdebug: state %d, shifting to state %d\n",
                    EXP_YYPREFIX, exp_yystate, exp_yytable[exp_yyn]);
#endif
        if (exp_yystack.s_mark >= exp_yystack.s_last && exp_yygrowstack(&exp_yystack))
        {
            goto exp_yyoverflow;
        }
        exp_yystate = exp_yytable[exp_yyn];
        *++exp_yystack.s_mark = exp_yytable[exp_yyn];
        *++exp_yystack.l_mark = exp_yylval;
        exp_yychar = EXP_YYEMPTY;
        if (exp_yyerrflag > 0)  --exp_yyerrflag;
        goto exp_yyloop;
    }
    if ((exp_yyn = exp_yyrindex[exp_yystate]) && (exp_yyn += exp_yychar) >= 0 &&
            exp_yyn <= EXP_YYTABLESIZE && exp_yycheck[exp_yyn] == exp_yychar)
    {
        exp_yyn = exp_yytable[exp_yyn];
        goto exp_yyreduce;
    }
    if (exp_yyerrflag) goto exp_yyinrecovery;

    exp_yyerror("syntax error");

    goto exp_yyerrlab;

exp_yyerrlab:
    ++exp_yynerrs;

exp_yyinrecovery:
    if (exp_yyerrflag < 3)
    {
        exp_yyerrflag = 3;
        for (;;)
        {
            if ((exp_yyn = exp_yysindex[*exp_yystack.s_mark]) && (exp_yyn += EXP_YYERRCODE) >= 0 &&
                    exp_yyn <= EXP_YYTABLESIZE && exp_yycheck[exp_yyn] == EXP_YYERRCODE)
            {
#if EXP_YYDEBUG
                if (exp_yydebug)
                    TRACE("%sdebug: state %d, error recovery shifting\
 to state %d\n", EXP_YYPREFIX, *exp_yystack.s_mark, exp_yytable[exp_yyn]);
#endif
                if (exp_yystack.s_mark >= exp_yystack.s_last && exp_yygrowstack(&exp_yystack))
                {
                    goto exp_yyoverflow;
                }
                exp_yystate = exp_yytable[exp_yyn];
                *++exp_yystack.s_mark = exp_yytable[exp_yyn];
                *++exp_yystack.l_mark = exp_yylval;
                goto exp_yyloop;
            }
            else
            {
#if EXP_YYDEBUG
                if (exp_yydebug)
                    TRACE("%sdebug: error recovery discarding state %d\n",
                            EXP_YYPREFIX, *exp_yystack.s_mark);
#endif
                if (exp_yystack.s_mark <= exp_yystack.s_base) goto exp_yyabort;
                --exp_yystack.s_mark;
                --exp_yystack.l_mark;
            }
        }
    }
    else
    {
        if (exp_yychar == 0) goto exp_yyabort;
#if EXP_YYDEBUG
        if (exp_yydebug)
        {
            exp_yys = 0;
            if (exp_yychar <= EXP_YYMAXTOKEN) exp_yys = exp_yyname[exp_yychar];
            if (!exp_yys) exp_yys = "illegal-symbol";
            TRACE("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    EXP_YYPREFIX, exp_yystate, exp_yychar, exp_yys);
        }
#endif
        exp_yychar = EXP_YYEMPTY;
        goto exp_yyloop;
    }

exp_yyreduce:
#if EXP_YYDEBUG
    if (exp_yydebug)
        TRACE("%sdebug: state %d, reducing by rule %d (%s)\n",
                EXP_YYPREFIX, exp_yystate, exp_yyn, exp_yyrule[exp_yyn]);
#endif
    exp_yym = exp_yylen[exp_yyn];
    if (exp_yym)
        exp_yyval = exp_yystack.l_mark[1-exp_yym];
    else
        memset(&exp_yyval, 0, sizeof exp_yyval);
    switch (exp_yyn)
    {
case 1:
	{ m_value = exp_yystack.l_mark[0].token.coeff; }
break;
case 2:
	{
		/* expression '+' expression*/
		exp_yyval.token = poly.Add( exp_yystack.l_mark[-2].token, exp_yystack.l_mark[0].token );
										}
break;
case 3:
	{
		/* expression '-' expression*/
		exp_yyval.token = poly.Subtract( exp_yystack.l_mark[-2].token, exp_yystack.l_mark[0].token );
										}
break;
case 4:
	{
		/* expression '*' expression*/
		exp_yyval.token = poly.Multiply( exp_yystack.l_mark[-2].token, exp_yystack.l_mark[0].token );
										}
break;
case 5:
	{ 
		/* expression '/' expression*/
		exp_yyval.token = poly.Divide( exp_yystack.l_mark[-2].token, exp_yystack.l_mark[0].token );
										}
break;
case 6:
	{
		/* expression '^' expression*/
		exp_yyval.token = poly.Exponentiate( exp_yystack.l_mark[-2].token, exp_yystack.l_mark[0].token );
										}
break;
case 7:
	{ exp_yyval.token.type = N; exp_yyval.token.coeff = RAD2DEG * asin( exp_yystack.l_mark[-1].token.coeff ); }
break;
case 8:
	{ exp_yyval.token.type = N; exp_yyval.token.coeff = RAD2DEG * acos( exp_yystack.l_mark[-1].token.coeff ); }
break;
case 9:
	{ exp_yyval.token.type = N; exp_yyval.token.coeff = RAD2DEG * atan( exp_yystack.l_mark[-1].token.coeff ); }
break;
case 10:
	{ exp_yyval.token.type = N; exp_yyval.token.coeff = sin( DEG2RAD * exp_yystack.l_mark[-1].token.coeff ); }
break;
case 11:
	{ exp_yyval.token.type = N; exp_yyval.token.coeff = cos( DEG2RAD * exp_yystack.l_mark[-1].token.coeff ); }
break;
case 12:
	{ exp_yyval.token.type = N; exp_yyval.token.coeff = tan( DEG2RAD * exp_yystack.l_mark[-1].token.coeff ); }
break;
case 13:
	{ exp_yyval.token.type = N; exp_yyval.token.coeff = exp_yystack.l_mark[-1].token.coeff * RAD2DEG; }
break;
case 14:
	{ exp_yyval.token.type = N; exp_yyval.token.coeff = exp_yystack.l_mark[-1].token.coeff * DEG2RAD; }
break;
case 15:
	{
		/* '(' expression ')'*/
		/* $$.type = N; $$.coeff = $2.coeff;*/
		exp_yyval.token = exp_yystack.l_mark[-1].token;
										}
break;
case 16:
	{
		/* '-' expression %prec UMINUS*/
		exp_yyval.token = poly.Negate( exp_yystack.l_mark[0].token );
										}
break;
case 17:
	{
		/* NUMBER*/
		exp_yyval.token = poly.PushNumber( exp_yystack.l_mark[0].token );
										}
break;
case 18:
	{
		/* VAR*/
		exp_yyval.token = poly.PushVariable( exp_yystack.l_mark[0].token );
										}
break;
    }
    exp_yystack.s_mark -= exp_yym;
    exp_yystate = *exp_yystack.s_mark;
    exp_yystack.l_mark -= exp_yym;
    exp_yym = exp_yylhs[exp_yyn];
    if (exp_yystate == 0 && exp_yym == 0)
    {
#if EXP_YYDEBUG
        if (exp_yydebug)
            TRACE("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", EXP_YYPREFIX, EXP_YYFINAL);
#endif
        exp_yystate = EXP_YYFINAL;
        *++exp_yystack.s_mark = EXP_YYFINAL;
        *++exp_yystack.l_mark = exp_yyval;
        if (exp_yychar < 0)
        {
            if ((exp_yychar = EXP_YYLEX) < 0) exp_yychar = 0;
#if EXP_YYDEBUG
            if (exp_yydebug)
            {
                exp_yys = 0;
                if (exp_yychar <= EXP_YYMAXTOKEN) exp_yys = exp_yyname[exp_yychar];
                if (!exp_yys) exp_yys = "illegal-symbol";
                TRACE("%sdebug: state %d, reading %d (%s)\n",
                        EXP_YYPREFIX, EXP_YYFINAL, exp_yychar, exp_yys);
            }
#endif
        }
        if (exp_yychar == 0) goto exp_yyaccept;
        goto exp_yyloop;
    }
    if ((exp_yyn = exp_yygindex[exp_yym]) && (exp_yyn += exp_yystate) >= 0 &&
            exp_yyn <= EXP_YYTABLESIZE && exp_yycheck[exp_yyn] == exp_yystate)
        exp_yystate = exp_yytable[exp_yyn];
    else
        exp_yystate = exp_yydgoto[exp_yym];
#if EXP_YYDEBUG
    if (exp_yydebug)
        TRACE("%sdebug: after reduction, shifting from state %d \
to state %d\n", EXP_YYPREFIX, *exp_yystack.s_mark, exp_yystate);
#endif
    if (exp_yystack.s_mark >= exp_yystack.s_last && exp_yygrowstack(&exp_yystack))
    {
        goto exp_yyoverflow;
    }
    *++exp_yystack.s_mark = (short) exp_yystate;
    *++exp_yystack.l_mark = exp_yyval;
    goto exp_yyloop;

exp_yyoverflow:
    exp_yyerror("yacc stack overflow");

exp_yyabort:
    exp_yyfreestack(&exp_yystack);
    return (1);

exp_yyaccept:
    exp_yyfreestack(&exp_yystack);
    return (0);
}
