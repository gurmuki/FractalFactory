
%{

//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
// BEGIN ** my additions **
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// NOTE: This source file is was generated by cygwin's byacc.exe
//   i.e. byacc -d -l -o CmdParser.cpp CmdParser.y
//
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#include "stdafx.h"
#include <map>
#include <stack>
#include <math.h>
#include "MathConst.h"
#include "TokenData.h"
#include "PolyMath.h"

// The lexer (of course).
extern int yylex();

// See also notes at yyForceRestart().
extern void yyForceRestart();

// A forward reference (compiler fodder)
int yyparse();

// m_expression is the text we are parsing.
char*	m_expression;
double	m_value;
bool	m_error;

PolyMath poly;

%}

%union
{
	TokenData token;
}

%token <token>		NUMBER
%token <token>		VAR

%type <token>		expression

%left OP_EQ, OP_LE, OP_GE, OP_LT, OP_GT, OP_NE
%left OP_AND, OP_OR, OP_XOR, OP_MIN, OP_MAX
%nonassoc OP_LSHIFT, OP_RSHIFT
%left '+', '-'
%left '*', '/', '%'
%left '&', '|', '^'
%right OP_SIN, OP_COS, OP_TAN, OP_ASIN, OP_ACOS, OP_ATAN, OP_RAD, OP_DEG
%right UMINUS

%%

// ============================================================================
//	main
//
main:
	expression							{ m_value = $1.coeff; }
	;

// ============================================================================
//		expression:  Mathematical expressions
//
//
expression:
	expression '+' expression			{
		// expression '+' expression
		$$ = poly.Add( $1, $3 );
										}
	| expression '-' expression			{
		// expression '-' expression
		$$ = poly.Subtract( $1, $3 );
										}
	| expression '*' expression			{
		// expression '*' expression
		$$ = poly.Multiply( $1, $3 );
										}
	| expression '/' expression			{ 
		// expression '/' expression
		$$ = poly.Divide( $1, $3 );
										}
	| expression '^' expression			{
		// expression '^' expression
		$$ = poly.Exponentiate( $1, $3 );
										}
	| OP_ASIN '(' expression ')'		{ $$.type = N; $$.coeff = RAD2DEG * asin( $3.coeff ); }
	| OP_ACOS '(' expression ')'		{ $$.type = N; $$.coeff = RAD2DEG * acos( $3.coeff ); }
	| OP_ATAN '(' expression ')'		{ $$.type = N; $$.coeff = RAD2DEG * atan( $3.coeff ); }
	| OP_SIN '(' expression ')'			{ $$.type = N; $$.coeff = sin( DEG2RAD * $3.coeff ); }
	| OP_COS '(' expression ')'			{ $$.type = N; $$.coeff = cos( DEG2RAD * $3.coeff ); }
	| OP_TAN '(' expression ')'			{ $$.type = N; $$.coeff = tan( DEG2RAD * $3.coeff ); }
	| OP_DEG '(' expression ')'			{ $$.type = N; $$.coeff = $3.coeff * RAD2DEG; }
	| OP_RAD '(' expression ')'			{ $$.type = N; $$.coeff = $3.coeff * DEG2RAD; }


	| '(' expression ')'				{
		// '(' expression ')'
		// $$.type = N; $$.coeff = $2.coeff;
		$$ = $2;
										}
	| '-' expression %prec UMINUS		{
		// '-' expression %prec UMINUS
		$$ = poly.Negate( $2 );
										}
	| NUMBER							{
		// NUMBER
		$$ = poly.PushNumber( $1 );
										}
	| VAR								{
		// VAR
		$$ = poly.PushVariable( $1 );
										}
	;

%%

// ============================================================================

extern "C" __declspec(dllexport) int __cdecl ExpParse( const char* expression )
{
	int	status;

	m_value = UNDEFINED;
	m_error = false;

	m_expression = (char*) expression;

	poly.Reset();
	status = yyparse();

	return status;
}

extern __declspec(dllexport) std::string __cdecl ExpParseExpressionGet()
{
	return poly.Expression();
}

extern "C" __declspec(dllexport) int __cdecl ExpParseCountOfTerms()
{
	poly.Reduce();
	return (poly.Terms().size());
}

extern "C" __declspec(dllexport) void __cdecl ExpParseTermsGet(int count, double* coeff, double* expon)
{
	const ExpCoeffs& terms = poly.Terms();
	int limit = terms.size();

	int indx;
	for (indx = 0; indx < count; ++indx)
	{
		coeff[indx] = 0.;
		expon[indx] = 0.;
	}

	indx = 0;
    ExpCoeffs::const_reverse_iterator iter = terms.rbegin();
    while (iter != terms.rend())
	{
		coeff[indx] = iter->second;
		expon[indx] = iter->first;

		++indx;
        ++iter;
	}
}

void yyerror( const char* in_error )
{
	m_error = true;
	yyForceRestart();
}
